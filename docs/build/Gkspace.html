<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>$\mathbb{G}_k$ Space · LiGA- Library for Geometric Algebra</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="LiGA- Library for Geometric Algebra logo"/></a><h1>LiGA- Library for Geometric Algebra</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Overview</a></li><li><a class="toctext" href="gettingstarted.html">Getting Started</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="types.html">Types</a></li><li class="current"><a class="toctext" href="Gkspace.html">$\mathbb{G}_k$ Space</a><ul class="internal"><li><a class="toctext" href="#Functions-and-Operations-1">Functions and Operations</a></li><li><a class="toctext" href="#Examples-1">Examples</a></li><li><a class="toctext" href="#Matrix-operations-1">Matrix operations</a></li></ul></li><li><a class="toctext" href="projspace.html">Projective Space ($\mathbb{G}_{k+1}$)</a></li><li><a class="toctext" href="confspace.html">Conformal Space ($\mathbb{G}_{k+1,1}$)</a></li><li><a class="toctext" href="advancedex.html">Advanced Examples</a></li></ul></li><li><a class="toctext" href="summary.html">Summaries</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href="Gkspace.html">$\mathbb{G}_k$ Space</a></li></ul><a class="edit-page" href="https://github.com/evcastelani/Liga.jl/blob/master/docs/src/Gkspace.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>$\mathbb{G}_k$ Space</span><a class="fa fa-bars" href="#"></a></div></header><div></div><h1><a class="nav-anchor" id="\\mathbb{G}_k-Space-1" href="#\\mathbb{G}_k-Space-1">$\mathbb{G}_k$ Space</a></h1><p>The Euclidean geometric algebra $G_k$ space is the basic space of this project. The main operations of the space, that is, the <em>Clifford</em> or <em>geometric product</em>, the <em>inner</em>, <em>outer</em> and <em>scalar</em> products, the <em>reverse</em>, <em>dual</em>, <em>projection</em> and <em>rejection</em> of elements of this space are programmed and ready for use.</p><p>To create an element of this space is necessary to call the <strong>types</strong> which have only elements of type <code>kbasis</code> in their composition, that is, the elements of the <em>type</em> <code>kbasis</code> itself, the <code>kmultvec</code> and the <code>kblade</code> <em>types</em>. Functions and operations related to this space  can be used in projetive and conformal space, but we explain in <a href="projspace.html">Projetive Space Section</a> this.</p><p><strong>If the reader has not yet read about the types supported by this library, reading in <a href="types.html">Section Types</a> is highly recommended.</strong></p><h2><a class="nav-anchor" id="Functions-and-Operations-1" href="#Functions-and-Operations-1">Functions and Operations</a></h2><p>Here we will give an explanation of how each <em>function</em> works, in terms of what is taken as the <em>input</em> parameter and what the <em>function</em> will return, so that some detailed examples are given later in order to simplify the understanding of the program and avoid possible mistakes.</p><h3><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h3><h4><a class="nav-anchor" id="Geometric-Product-geoprod(a,b)-or-a-b-1" href="#Geometric-Product-geoprod(a,b)-or-a-b-1">Geometric Product - <code>geoprod(a,b)</code> or <code>a ∘ b</code></a></h4><p>As in the literature, the <em>Clifford</em> or <em>geometric product</em> is the main operation of the space, and is the basis for most of the other operations. It takes two elements of the <em>type</em> <code>kbasis</code>, <code>kmultvec</code> or <code>kblade</code> and return their <em>geometric product</em>.</p><pre><code class="language-none">geoprod(a::kbasis, b::kbasis)
geoprod(X::kmultvec, Y::kmultvec)
geoprod(A::kblade, B::kblade)</code></pre><p>To simplify the operation <em>input</em> it can be used the base operator <code>∘</code> instead of call the <em>function</em> <code>geoprod</code>.</p><pre><code class="language-none"> Base.:∘(a::kbasis, b::kbasis)
 Base.:∘(X::kmultvec, Y::kmultvec)
 Base.:∘(A::kblade, B::kblade)</code></pre><p>In order to obtain the <em>geometric product</em> of elements of different <em>types</em>,as long as the operator is used, it is not necessary to convert them before . As explained above, since a generic element of <em>geometric algebra</em> is a <em>multivector</em>, the elements of type <code>kbasis</code> and <code>kblade</code> can be converted to the <em>type</em> <code>kmultvec</code> and thus can be apply the <em>geometric product</em> operation. These conversions are done automatically when two parameters of different <em>types</em> are used as input.</p><p>See <strong>Examples</strong> section below to better understand the <em>input</em> and <em>output</em> of operations.</p><h4><a class="nav-anchor" id="Inner-Product-inner(a,b)-or-a-b-1" href="#Inner-Product-inner(a,b)-or-a-b-1">Inner Product - <code>inner(a,b)</code> or <code>a ⋅ b</code></a></h4><p>The <em>input</em> parameters for the <em>inner product</em> are of the same <em>types</em> as for the <em>geometric product</em>, so to obtain the <em>inner product</em> between two elements of <em>type</em> <code>kbasis</code>, <code>kmultvec</code> or <code>kblade</code> just use the <code>inner</code> <em>function</em>.</p><pre><code class="language-none"> inner(a::kbasis, b::kbasis)
 inner(X::kmultvec, Y::kmultvec)
 inner(A::kblade, B::kblade)</code></pre><p>As for the <em>geometric product</em>, to obtain the <em>inner product</em> is sufficient to use a base operator, in this case, the operator <code>⋅</code> instead of call the <code>inner</code> <em>function</em>.</p><pre><code class="language-none"> Base.:⋅(a::kbasis, b::kbasis)
 Base.:⋅(X::kmultvec, Y::kmultvec)
 Base.:⋅(A::kblade, B::kblade)</code></pre><h4><a class="nav-anchor" id="Outer-Product-outer(a,b)-or-a-b-1" href="#Outer-Product-outer(a,b)-or-a-b-1">Outer Product - <code>outer(a,b)</code> or <code>a ^ b</code></a></h4><p>As for the <em>geometric</em> and <em>inner</em> products, one can use the <em>function</em> <code>outer</code> to obtain the <em>outer product</em> between two elements of <em>type</em> <code>kbasis</code>, <code>kmultvec</code> or <code>kblade</code>.</p><pre><code class="language-none"> outer(a::kbasis, b::kbasis)
 outer(X::kmultvec, Y::kmultvec)
 outer(A::kblade, B::kblade)</code></pre><p>The base operator that can be used instead of call the <em>function</em> in this case is the <code>^</code> symbol.</p><pre><code class="language-none"> Base.:^(a::kbasis, b::kbasis)
 Base.:^(X::kmultvec, Y::kmultvec)
 Base.:^(A::kblade, B::kblade)</code></pre><h4><a class="nav-anchor" id="Scalar-Product-scalar(a,b)-or-a-*-b-1" href="#Scalar-Product-scalar(a,b)-or-a-*-b-1">Scalar Product - <code>scalar(a,b)</code> or <code>a * b</code></a></h4><p>The <code>scalar</code> <em>function</em> is not different from the other three mentioned above, in order to obtain the <em>scalar product</em> between two elements of <em>type</em> <code>kbasis</code>, <code>kmultvec</code> or <code>kblade</code> just use the <em>function</em> <code>inner</code>.</p><pre><code class="language-none"> scalar(a::kbasis, b::kbasis)
 scalar(X::kmultvec, Y::kmultvec)
 scalar(A::kblade, B::kblade)</code></pre><p>Or using the base operator <code>*</code>.</p><pre><code class="language-none"> Base.:*(a::kbasis, b::kbasis)
 Base.:*(X::kmultvec, Y::kmultvec)
 Base.:* (A::kblade, B::kblade)</code></pre><p><strong>In this operation, unlike the previous ones, the output parameter will always be of <em>type</em> <code>Number</code>.</strong></p><h4><a class="nav-anchor" id="Sum-and-difference-mvsum(a,b)-or-a-b-and-a-b-1" href="#Sum-and-difference-mvsum(a,b)-or-a-b-and-a-b-1">Sum and difference - <code>mvsum(a,b)</code> or <code>a + b</code> and <code>a - b</code></a></h4><p>This <em>function</em> has a particularity in the <em>type</em> of <em>output</em>, since the <em>sum</em> of two elements of <em>type</em> <code>kbasis</code> will only be of <em>type</em> <code>kbasis</code> if they are l.d, otherwise the output will be of <em>type</em> <code>kmultvec</code>.</p><p>To obtain the <em>sum</em> of two elements of <em>types</em> <code>kbasis</code>,  <code>kmultvec</code> or <code>kblade</code>, one can call the <em>function</em> <code>mvsum</code>, as well as the previous functions,</p><pre><code class="language-none"> mvsum(a::kbasis, b::kbasis)
 mvsum(X::kmultvec, Y::kmultvec)
 mvsum(A::kblade, B::kblade)</code></pre><p>or using the base operator <code>+</code></p><pre><code class="language-none"> Base.:+(a::kbasis, b::kbasis)
 Base.:+(X::kmultvec, Y::kmultvec)
 Base.:+(A::kblade, B::kblade)</code></pre><p>but, to make it easier, in addition to the base operator <code>+</code>, it can be used the base operator <code>-</code> which convert the second element to its <em>additive inverse</em>.</p><pre><code class="language-none"> Base.:-(a::kbasis, b::kbasis)
 Base.:-(X::kmultvec, Y::kmultvec)
 Base.:-(A::kblade, B::kblade)</code></pre><p>thus obtaining the <em>difference</em> between the two elements.</p><h3><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h3><h4><a class="nav-anchor" id="Grade-grade(a)-1" href="#Grade-grade(a)-1">Grade - <code>grade(a)</code></a></h4><p>The <em>grade function</em> take as <em>input</em> an element of the <em>type</em> <code>kbasis</code> and return its grade which is an element of the <em>type</em> <code>Int</code>, it&#39;s used more as an auxiliary <em>function</em>.</p><pre><code class="language-none"> grade(a::kbasis)</code></pre><h4><a class="nav-anchor" id="Dual-dual(a)-1" href="#Dual-dual(a)-1">Dual - <code>dual(a)</code></a></h4><p>The <em>dual function</em>, as the name suggests, returns its dual element, taking as <em>input</em> elements of <em>types</em> <code>kbasis</code>,  <code>kmultvec</code> or <code>kblade</code>.</p><pre><code class="language-none"> dual(a::kbasis)
 dual(X::kmultvec)
 dual(A::kblade)</code></pre><p>As for the <em>products</em> and <em>sum</em>, in case the <em>input</em> of the <code>kblade</code> the <em>output</em> will be of the <em>type</em> <code>kmultvec</code>.</p><h4><a class="nav-anchor" id="Reverse-mvreverse(a)-1" href="#Reverse-mvreverse(a)-1">Reverse - <code>mvreverse(a)</code></a></h4><p>Returns the <em>reverse</em> of the <em>input</em> element, but, unlike other <em>functions</em>, this will always return an element of the same <em>input type</em>, being it <code>kbasis</code>,  <code>kmultvec</code> or <code>kblade</code>.</p><pre><code class="language-none"> mvreverse(a::kbasis)
 mvreverse(X::kmultvec)
 mvreverse(A::kblade)</code></pre><p>The conjugation <em>function</em> isn&#39;t necessary in $G_k$ space, since its depends of negative grade.</p><h4><a class="nav-anchor" id="Magnitude-1" href="#Magnitude-1">Magnitude</a></h4><p>The <em>magnitude function</em> receives as <em>input</em> an element of type <code>kbasis</code>,  <code>kmultvec</code> or <code>kblade</code> and returns its magnitude of the <em>type</em> <code>Ǹumber</code>.</p><pre><code class="language-none"> magnitude(a::kbasis)
 magnitude(X::kmultvec)
 magnitude(A::kblade)</code></pre><h3><a class="nav-anchor" id="Special-functions-1" href="#Special-functions-1">Special functions</a></h3><p>In this space, some <em>functions</em> will work only with elements of the <em>type</em> <code>kblade</code>, one being the <em>inversion function</em> and the other two depending on the first one, since not every multivector of Gₖ has inverse with respect to the <em>geometric product</em>.</p><h4><a class="nav-anchor" id="Inversion-1" href="#Inversion-1">Inversion</a></h4><p>This <em>function</em> returns the <em>inverse</em> element of the <em>input</em> with respect to the <em>geometric product</em>.</p><pre><code class="language-none"> inverse(A::kblade)</code></pre><p>The <em>output type</em> will also be <code>kblade</code>.</p><h4><a class="nav-anchor" id="Projection-1" href="#Projection-1">Projection</a></h4><p>The <em>projection</em> is a simple <em>function</em> that depends on two elements of the <em>type</em> <code>kblade</code></p><pre><code class="language-none"> projection(A::kblade, N::kblade)</code></pre><p>and it returns, in this case, the <em>projection</em> of <code>A</code> onto <code>N</code>, which will be an element of the <em>type</em> <code>kmultvec</code>.</p><h4><a class="nav-anchor" id="Rejection-1" href="#Rejection-1">Rejection</a></h4><p>The <em>rejection function</em> also receives two elements of the <em>type</em> <code>kblade</code> as input</p><pre><code class="language-none"> rejection(A::kblade, N::kblade)</code></pre><p>and, as for the <em>projection</em>, it returns an element of the <em>type</em> <code>kmultvec</code> which will be the <em>rejection</em> of the <code>kblade</code> <code>A</code> from the <code>kblade</code>  <code>N</code>.</p><h2><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h2><p>All of the following examples are based on <code>layout(3)</code>, that is, the space generated will be $\mathbb{G}_3$ depending on the objects <code>id</code>, <code>e1</code>, <code>e2</code>, <code>e3</code>, <code>e12</code>, <code>e13</code>, <code>e23</code> and <code>e123</code>, however everything follows in the same way for other dimensions.</p><h4><a class="nav-anchor" id="Grade-1" href="#Grade-1">Grade</a></h4><p>The grade <em>function</em> is the most basic of them, as mentioned above, it&#39;s used more like an auxiliary <em>function</em> for the other and it returns the grade of a <code>kbasis</code> element as follows:</p><pre><code class="language-julia-repl">julia&gt; grade(kbasis(e12, 1.0))
2</code></pre><p>which is the grade of <code>e12</code>.</p><p>Another way to do this is by calling the element before the <em>function</em></p><pre><code class="language-julia-repl">julia&gt; a = kbasis(e123, -2.3)
-2.3e123</code></pre><p>and then use the grade <em>function</em></p><pre><code class="language-julia-repl">julia&gt; grade(a)
3</code></pre><p>which is the grade of <code>-2.3e123</code>.</p><h4><a class="nav-anchor" id="Geometric,-inner,-outer-and-scalar-products-1" href="#Geometric,-inner,-outer-and-scalar-products-1">Geometric, inner, outer and scalar products</a></h4><p>The <em>geometric, inner and outer products</em> in case the <em>input</em> elements are of <em>type</em> <code>kd</code> or <code>kmultvec</code>, will always return the same type, even if the result is a <em>scalar</em> or a <em>basis blade</em>, that is, if the following elements are called:</p><pre><code class="language-julia-repl">julia&gt; a = kbasis(e3, 2.0)
2.0e3

julia&gt; b = kbasis(e12, -1.0)
-e12

julia&gt; c = kbasis(id, 0.0)
0.0

julia&gt; d = kbasis(e123)
1.0e123</code></pre><p>when operated, for example</p><pre><code class="language-julia-repl">julia&gt; geoprod(a, b)
-2.0e123</code></pre><p>which is a <code>kbasis</code> element, although when operated</p><pre><code class="language-julia-repl">julia&gt; inner(a, b)
0.0</code></pre><p>this element is seen as an object of <em>type</em> <code>kbasis</code>. Note that if a second parameter is not placed when called the <code>kbasis</code> type it will be generated with the scalar 1.0.</p><p>As mentioned before, we can use the base operators <code>∘</code>, <code>⋅</code> and <code>^</code> to calculate these products instead of call the functions</p><pre><code class="language-julia-repl">julia&gt; a ^ c
ERROR: UndefVarError: a not defined

julia&gt; b ⋅ d
ERROR: UndefVarError: b not defined</code></pre><p>The same is true if the input is of the type kmultvec as follows:</p><pre><code class="language-julia-repl">julia&gt; X = kmultvec([kbasis(e12,2.0),kbasis(e123,-1.5),kbasis(e3,4.0)])
2.0e12-1.5e123+4.0e3

julia&gt; Y = kmultvec([a, b, kbasis(id, 2.0)])
2.0e3-e12+2.0

julia&gt; Z = kmultvec(d)
1.0e123</code></pre><p>and these can be operated in the same way as the previous ones</p><pre><code class="language-julia-repl">julia&gt; X ∘ Y
-3.0e123+1.0e12+10.0+6.5e3

julia&gt; Y ⋅ Z
2.0e12+1.0e3+2.0e123

julia&gt; Y ^ Z
2.0e123</code></pre><p>Now, in the case of <code>kblade</code> <em>type</em>, everything follows like the previous cases, the difference is in the <em>output</em> of the <em>function</em>. For example, if we call the following <code>kblade</code> elements</p><pre><code class="language-julia-repl">julia&gt; A = kblade([kmultvec([kb(e1)]), kmultvec([kb(e2)]), kmultvec([kb(e3)])])
(1.0e1)∧(1.0e2)∧(1.0e3)

julia&gt; B = kblade([kmultvec([kb(e1, 2.0), a]), kmultvec([kb(e1, 3.0)])])
(2.0e1+2.0e3)∧(3.0e1)

julia&gt; C = kblade([kmultvec(a)])
(2.0e3)

julia&gt; A ⋅ B
-6.0e2</code></pre><p>returns an element of the <em>type</em>  <code>kmultvec</code>. In fact, type</p><pre><code class="language-julia-repl">julia&gt; typeof(A ⋅ B)
Liga.kmultvec</code></pre><p>the same will happen for the other operations</p><pre><code class="language-none"> B ^ C</code></pre><p>returns</p><pre><code class="language-none"> 0.0</code></pre><p>and</p><pre><code class="language-none"> B ∘ C</code></pre><p>returns</p><pre><code class="language-none"> -12.0e1</code></pre><p>The <em>scalar product</em> follows a different rule, in all cases the <em>output</em> will always be of <em>Number</em>. For example, if we want to calculate the <em>scalar product</em> between the <code>kbasis</code> element <code>d</code> and the <code>kblade</code> <code>A</code> previously called simply do as follows:</p><pre><code class="language-julia-repl">julia&gt; d=kbasis(id,-2.0)
-2.0

julia&gt; d * A
0.0</code></pre><p>remember that this is an element of <em>type</em> <code>Number</code>.</p><pre><code class="language-julia-repl">julia&gt; typeof(ans)
Float64</code></pre><p>You can operate any other elements of <em>types</em> <code>kbasis</code>, <code>kmultvec</code> and <code>kblade</code>,  </p><pre><code class="language-julia-repl">julia&gt;  a * a
4.0

julia&gt;  b * X
2.0

julia&gt;  B * B
-36.0

julia&gt;  X * A
1.5</code></pre><h4><a class="nav-anchor" id="Sum-and-difference-1" href="#Sum-and-difference-1">Sum and difference</a></h4><p>The <em>mvsum</em> operation works in the same way as the previous ones with respect to the <em>input</em> parameters, the difference is in the <em>output</em> parameters, which in the case of the <em>sum</em> of elements of the <em>type</em> <code>kbasis</code> the <em>output</em> there are two possible <em>outputs</em></p><pre><code class="language-julia-repl">julia&gt; mvsum(kbasis(e23, 2.3), kbasis(e23, 2.7))
5.0e23</code></pre><p>in this case, it may be noted that the parameter <code>e23</code> is used in the construction of both <em>inputs</em>, then the it returns</p><pre><code class="language-none"> 5.0e23</code></pre><p>which is of the <em>type</em> <code>kbasis</code>,</p><pre><code class="language-julia-repl">julia&gt; typeof(ans)
Liga.kbasis</code></pre><p>However, if we calculate the following sum</p><pre><code class="language-none"> a + b</code></pre><p>it returns</p><pre><code class="language-none"> 2.0e3 + -e12</code></pre><p>which is of the <em>type</em> <code>kmultvec</code>, remembering that <code>a</code> and <code>b</code> are the elements <code>kbasis(e3, 2.0)</code> and <code>kbasis(e12, -1.0)</code> called above.</p><p>Other than that, the rest follows as before</p><pre><code class="language-julia-repl">julia&gt; A + B
1.0e123-6.0e13

julia&gt; typeof(ans)
Liga.kmultvec

julia&gt; X - C
2.0e12-1.5e123+2.0e3

julia&gt; typeof(ans)
Liga.kmultvec

julia&gt; d + Y
2.0e3-e12

julia&gt; typeof(ans)
Liga.kmultvec

julia&gt; a + d
2.0e3-2.0

julia&gt; typeof(ans)
Liga.kmultvec</code></pre><p>Note that here we can use either the base operator <code>+</code> or <code>-</code>.</p><p>Again, the <em>output</em> when applied the <em>sum</em> and the <em>difference</em>  between elements of the <em>type</em> <code>kblade</code> will be of the <em>type</em> <code>kmultvec</code>.</p><h4><a class="nav-anchor" id="Dual-1" href="#Dual-1">Dual</a></h4><p>The <em>dual function</em> returns the dual of the <em>input</em> element as follows</p><pre><code class="language-julia-repl">julia&gt; dual(a)
-2.0e12

julia&gt; typeof(dual(a))
Liga.kbasis

julia&gt; dual(X)
2.0e3-1.5-4.0e12

julia&gt; typeof(dual(X))
Liga.kmultvec

julia&gt; dual(A)
1.0

julia&gt; typeof(dual(A))
Liga.kmultvec</code></pre><p>As for the previous operations, except for the <em>scalar product</em>, in case the <em>input</em> is of <em>type</em> <code>kblade</code> the <em>output</em> will be of <em>type</em> <code>kmultvec</code>.</p><h4><a class="nav-anchor" id="Reverse-1" href="#Reverse-1">Reverse</a></h4><p>Unlike other <em>functions</em> and <em>operations</em> the <em>mvreverse</em> function returns an element of the same <em>type</em> as the <em>input</em>, be it <code>kbasis</code>, <code>kmultvec</code> or <code>kblade</code></p><pre><code class="language-julia-repl">julia&gt; mvreverse(a)
2.0e3

julia&gt; typeof(mvreverse(a))
Liga.kbasis

julia&gt; mvreverse(X)
-2.0e12+1.5e123+4.0e3

julia&gt; typeof(mvreverse(X))
Liga.kmultvec

julia&gt; mvreverse(A)
(1.0e3)∧(1.0e2)∧(1.0e1)

julia&gt; typeof(mvreverse(A))
Liga.kblade</code></pre><h4><a class="nav-anchor" id="Magnitude-2" href="#Magnitude-2">Magnitude</a></h4><p>The <em>magnitude</em> in $\mathbb{G}_k$ is nothing more than the square root of the <em>scalar product</em> of an element by its reverse, so it is, like the scalar product, always returns an element of <em>type</em> <code>Float</code>. For example,</p><pre><code class="language-julia-repl">julia&gt; magnitude(a)
2.0

julia&gt; typeof(magnitude(a))
Float64

julia&gt; magnitude(X)
4.716990566028302

julia&gt; typeof(magnitude(X))
Float64

julia&gt; magnitude(A)
1.0

julia&gt; typeof(magnitude(A))
Float64</code></pre><h4><a class="nav-anchor" id="Inversion-2" href="#Inversion-2">Inversion</a></h4><p>In current version of Liga, this important functions works just for <code>kblade</code> and  <code>kmultvec</code> types. We are improve to more types. The return is an equivalent type to  input.</p><pre><code class="language-julia-repl">julia&gt; inverse(A)
(1.0e3)∧(1.0e2)∧(1.0e1)

julia&gt; typeof(inverse(A))
Liga.kblade

julia&gt; inverse(B)
(0.08333333333333333e1)∧(2.0e1+2.0e3)

julia&gt; typeof(inverse(B))
Liga.kblade

julia&gt; inverse(C)
(0.5e3)

julia&gt; typeof(inverse(C))
Liga.kblade</code></pre><p>it returns the inverse elements of <code>A</code>,<code>B</code> and <code>C</code>.</p><p>We can test the function using the <em>geometric product</em> of a <code>kblade</code> by its <em>inverse</em>, and it should return 1.0</p><pre><code class="language-julia-repl">julia&gt; A ∘ inverse(A)
1.0

julia&gt; B ∘ inverse(B)
1.0

julia&gt; C ∘ inverse(C)
1.0</code></pre><p>Note that as mentioned when dealing with the <em>geometric product</em>, this is a element of <em>type</em> <code>kmultvec</code></p><pre><code class="language-julia-repl">julia&gt; typeof(B ∘ inverse(B))
Liga.kmultvec</code></pre><p>Let us see an example related to <em>k-multivector</em>. </p><pre><code class="language-julia-repl">julia&gt; inverse(X)
0.05228046289993193-0.07733151803948264e12+0.19387338325391423e3+0.04656228727025188e123

julia&gt; typeof(inverse(X))
Liga.kmultvec

julia&gt; X ∘ inverse(X)
2.7755575615628914e-17e12-1.3877787807814457e-17e3+1.0

julia&gt; typeof(X ∘ inverse(X))
Liga.kmultvec</code></pre><p>Note that, in <code>X ∘ inverse(X)</code> the result was 2.7755575615628914e-17e12-1.3877787807814457e-17e3+1.0 wich is approximated 1.0 (and <code>kmultvec</code>);</p><h4><a class="nav-anchor" id="Projection-2" href="#Projection-2">Projection</a></h4><p>This function depends on the <em>inversion</em> and by now can be used only with elements of <em>type</em> <code>kblades</code> as <em>input</em>. For example,</p><pre><code class="language-none"> projection(A, B)
 projection(B, A)
 projection(A, C)</code></pre><p>will return</p><pre><code class="language-none"> e123
 6.0e13
 e123</code></pre><p>these <em>output</em> elements are of <em>type</em> <code>kmultvec</code></p><h4><a class="nav-anchor" id="Rejection-2" href="#Rejection-2">Rejection</a></h4><p>Like the above function <strong>Projection</strong>, the rejection receives an element of <em>type</em> <code>kblade</code> and returns an element of <em>type</em> <code>kmultvec</code> which is the <em>rejection</em> of the first <em>input</em> parameter from the second.</p><pre><code class="language-none"> rejection(B, kblade([kmultvec(kbasis(e2))]))</code></pre><p>will return</p><pre><code class="language-none"> 6.0e13</code></pre><p>which is the difference between the <code>kblade</code> <code>B</code> and the projection <code>rejection(B, kblade([kmultvec(kbasis(e2))]))</code>.</p><h2><a class="nav-anchor" id="Matrix-operations-1" href="#Matrix-operations-1">Matrix operations</a></h2><p>The main operations can be extended to array like the classic matrix product. For example, considering the geometric product</p><pre><code class="language-julia-repl">julia&gt; u=[1.0*e12;2.0*e123]
2-element Array{Liga.kbasis,1}:
 1.0e12
 2.0e123

julia&gt; transpose(u)∘u
1-element Array{Liga.kmultvec,1}:
 -5.0

julia&gt; A=[1.0*e1+2.0*e123 2.0*e1+1.0*id; 0.5*e123+1.0*e3 1.0*id+1.0*e1]
2×2 Array{Liga.kmultvec,2}:
 1.0e1+2.0e123  2.0e1+1.0
 0.5e123+1.0e3  1.0+1.0e1

julia&gt; B=[5.0*e12+2.0*e123 2.0*e1-1.0*id; 1.0*e123-2.0*e2 1.0*id+1.0*e1]
2×2 Array{Liga.kmultvec,2}:
 5.0e12+2.0e123  2.0e1-1
 1.0e123-2.0e2   1.0+1.0e1

julia&gt; A∘B
2×2 Array{Liga.kmultvec,2}:
 -4.0+3.0e2-10.0e3+4.0e23+1.0e123-4.0e12  5.0+4.0e23+2.0e1-2.0e123
 -1-2.5e3+6.0e123+1.0e23-2.0e2            1.0e23-2.0e13-0.5e123-e3+2.0+2.0e1</code></pre><p>Note in this example, additionally, a transpose function for array defined by kbasis or kmultvec types was implemented. Be carefull to use this function in keeping the same type, that is, the elements can be kmultvec or kbasis, but not both.</p><pre><code class="language-none">transpose(A::Array{kbasis,1})</code></pre><footer><hr/><a class="previous" href="types.html"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="projspace.html"><span class="direction">Next</span><span class="title">Projective Space ($\mathbb{G}_{k+1}$)</span></a></footer></article></body></html>
